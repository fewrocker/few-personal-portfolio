<%= render 'shared/navbar' %>

<div class="wrapper-page wrapper-project-everything">
  <%= link_to "/projects", class:"back-to-projects" do %>
    <i class="fas fa-chevron-left"></i> Back to projects
  <% end %>

  <div class="container-page container-project-everything">

    <%= link_to "https://www.every-thing.me/", target: "_blank" do %>
      <div class="everything-title-div text-center">
        <%= image_tag "projects-everything.png", class:"everything-title-logo" %>
        <p class="everything-title-description">
          Get great recommendations, easily
        </p>
      </div>
    <% end %>

    <h1 class="everything-section-title">
      Situation
    </h1>
    <p class="everything-section-text">
      Le Wagon was an incredible experience. The first 7 weeks are a continuous learning experience based on new concepts and tough challenges to internalize that knowledge. But it all culminates on the last 2 weeks.
    </p>
    <p class="everything-section-text">
      We had 2 weeks to come up with an idea, and bring that idea to life using all we have learnt. The result was two weeks of debating and coding all day long, and many times all night long. The result is <span class="everything-text-title">everything</span>.
    </p>
    <%= link_to "https://www.every-thing.me/", target: "_blank" do %>
      <div class="everything-gotosite text-center">
        <%= image_tag "projects-everything-1", class:"centered-image" %>
        <p class="everything-gotosite-text">Go to website!</p>
      </div>
    <% end %>

    <h1 class="everything-section-title">
      The problem
    </h1>
    <p class="everything-section-text">
      Building a recommendation system is a complex problem faced by many companies today. Companies which rely on sharing media content in exchange for a subscription fee know that their most important KPI is customer retention. And, as we find out, giving good recommendations is a huge factor to keep customers in your platform.
    </p>
    <p class="everything-section-text">
      The holy grail to make good recommendations is to gather good data from your customers about what they like and dislike. For some applications, making the bridge between how the user navigates the platform and his or her taste is easier: skipping songs and how long you listened to a song on Spotify, for example, is a very straightforward hint about what they think about the songs.
    </p>
    <p class="everything-section-text">
      However, other platforms like Netflix are known to have issues. Movies are way bigger than songs, so starting a movie to check some scenes and deciding to skip (don't like) or stay (like) isn't a thing. Also, there isn't a culture of really rating the movies and episodes after you watch them. And even if you do, many other users don't and, as we see, understanding similarity between users is a huge factor to give good recommendations.
    </p>
    <p class="everything-section-text">
      Other websites that try to help you choose your next movies aren't a good solution, either. The process of navigating through many titles, looking at details, trailer and comments can be tiring. Some websites try to assess your taste but they do it in a very boring way - you have to keep rating many and many movies on a 1-5 star scale, which feels more like work than entertainment.
    </p>

    <h1 class="everything-section-title">
      The solution
    </h1>
    <p class="everything-section-text">
      We created a platform that makes sharing your tastes about movies fun. Therefore, users actively want to keep rating, and the valuable info that so many companies failed to acquire arrives at the servers.
    </p>
    <p class="everything-section-text">
      The first feature that makes it fun is how you rate. There are mini-games within the platform in which to understand what you like or don't like. For now, we implemented a movie battle logic: we show you two movies and you tell us which one you prefer. We tested and people love doing that. And the best part: after a given number of battles, we are able to build a list of your movie preferences which gets very accurate.
    </p>
    <p class="everything-section-text">
      The cool part is that many other games can be made. We could build a whole tournament between movies (like some websites do and people play the tournament just for fun and to share the results), or build a Tinder-like platform in which people receive movies and swipe to say what they think about it. These forms of rating are more engaging and quickly absorbs taste data from users.
    </p>
    <p class="everything-section-text">
      You can also view a list of users and friends and see how similar they are to you. You can navigate between the movies to see how they are doing on the battles, and how many people know the movie versus how many don't. These kinds of information are very engaging when connected to social media, and tends to generate cool discussions between movie fans.
    </p>

    <div class="video text-center">
      <video src="/videos/projects-everything-video.mp4" autoplay loop muted class="centered-image-small"></video>
    </div>


    <h1 class="everything-section-title">
      How suggestions work
    </h1>
    <p class="everything-section-text">
      Recommendations systems can get very tricky and I want to show you why. There are basically two strategies of content recommendation: <strong>Content based</strong> and <strong>User similarity based</strong>.
    </p>
    <p class="everything-section-text">
      Content based is centered on the content. Each content has many characteristics. In case of movies, think: genre, duration, director, main actors, year of release, etc. Depending on how you like some movies, we can understand which are the common characteristics between what you like and show you more of that. The challenge with this model is that, for movies, it is very difficult to understand which characteristics correlate well with taste, apart from genre.
    </p>
    <p class="everything-section-text">
      User similarity based is centered on the users. You gather data about the tastes of your users, and then you can cluster them in groups of users which have a similar taste, and then you recommend a movie that the majority of the cluster likes but the receiving user has not yet seen. This eliminates the need of digging deep into the movie characteristics - you don't have to understand exactly why these users like the movie, but the fact that they do is enough. The challenge with this model is that to give good recommendations you need to start with a big user base which usually rates their movies. The problem, as we discussed, is that most users do not rate most movies.
    </p>
    <p class="everything-section-text">
      We picked a user similarity approach, and tackled its challenge: making users give ratings by making it fun. If everything gets a critical mass of happily rating individuals, the recommendations will get very sharp. The steps are straightforward: register and battle your movies. The platform will generate a list of your movies from best to worst. Then, it will compare your list with the lists of other users. Finally, it will look in the lists of most similar users for a movie they love, but you haven't yet seen.
    </p>
    <p class="everything-section-text">
      Curiosity: the animation on everything's homepage is inspired on how user similarity recommendations work!
    </p>

    <h1 class="everything-section-title">
      Code snippets
    </h1>

    <h2 class="everything-section-subtitle">
      Building the recommendation list (.rb)
    </h2>
    <p class="everything-section-text">
      <strong>Task:</strong> Build a list of movie recommendations to the user based on the similarity of his list and the list of most similar users
    </p>

    <div class="code-snippet">
      <button class="btn btn-success btn-expandcode">Click to expand code</button>
      <script src="https://gist.github.com/fewrocker/d7fd25990785c15a066714dcf00931eb.js" class="code-snippet"></script>
      <br>
      <button class="btn btn-success btn-expandcode btn-expandcode-bottom">Click to expand code</button>
    </div>

    <h2 class="everything-section-subtitle">
      Managing the battles (.js)
    </h2>
    <p class="everything-section-text">
      <strong>Task:</strong> The battlepage shows 2 movies for the user to pick. However, the user might have not seen one of these. We solve this problem by having Rails send a list of 10 movies to each of the 2 positions. If user hasn't seen one, he can click the "Haven't seen" button, and switch to the next movie. The app also has to update the Rails forms values. The app stores movies the user hasn't seen, so it doesn't appear again soon, and so that it can be recommended to the user later on. Also, when the user votes, the app needs to understand which films where battling during the time of decision
    </p>

    <div class="code-snippet">
      <button class="btn btn-success btn-expandcode">Click to expand code</button>
      <script src="https://gist.github.com/fewrocker/60e9af00b9b9b562e5a075cf4cafcd04.js"></script>
      <br>
      <button class="btn btn-success btn-expandcode btn-expandcode-bottom">Click to expand code</button>
    </div>
  </div>

  <%= link_to "/projects", class:"back-to-projects" do %>
    <i class="fas fa-chevron-left" style="margin-top: 60px;"></i> Back to projects
  <% end %>
</div>

<canvas id="nokey" >
</canvas>


<style>
  #nokey {
    width: 100%;
    background-color: #141414;
    z-index: 1;

    border-top: 2px solid rgba(220,220,220,0.05);
  }
  body {
    overflow-x: hidden;
    background-color: #141414;
  }
</style>

<script>
  // Everything - Canvas
  // Random moving dots that get connected by lines when they get close
  // This simulates the many users in the platform and the linking of similarity between them
  // This is how everything recommends Animations!
  // (This code was rewritten based on a code snippet from Matthew Willox)

  // ------------------------------------------------------------------------
  // Initiate canvas and get its dimensions
  var canvas = document.getElementById('nokey'),
     can_w = parseInt(canvas.getAttribute('width')),
     can_h = parseInt(canvas.getAttribute('height')),
     ctx = canvas.getContext('2d');

  // Basic varibles for the elements that will be rendered on the cavass
  // dot: you can customize color, size and opacity variation
  var dot = {
        x: 0,
        y: 0,
        v_x: 0,
        v_y: 0,
        r: 0,
        opac: 1,
        phase: 0
     },
     dot_color = {
         r: 185,
         g: 0,
         b: 255
     },
     R = 3,
     dots = [],
     opac_f = 0.03,
     opac_phase = 0,

  // Line: you can customize width and what is the max distance for dots to be connected
     line_wid = 0.8,
     dist_limit = 260,
     add_mouse_point = true,
     mouse_in = false,
     mouse_dot = {
        x: 0,
        y: 0,
        v_x: 0,
        v_y: 0,
        r: 0,
        type: 'mouse'
     };



  // Support functions - math
  // Get a random item from an array
  function randomArrayItem(arr){
      return arr[Math.floor(Math.random() * arr.length)];
  }
  // Get a random number from interval
  function randomNumFrom(min, max){
      return Math.random()*(max - min) + min;
  }

  // Calculate distance between two points
  function getDisOf(b1, b2){
      var  delta_x = Math.abs(b1.x - b2.x),
         delta_y = Math.abs(b1.y - b2.y);

      return Math.sqrt(delta_x*delta_x + delta_y*delta_y);
  }


  // Support functions: movement
  // Pick a dot that is present in the canvas
  // Randomize a direction
  function getRandomdot(){
      var pos = randomArrayItem(['top', 'right', 'bottom', 'left']);
      switch(pos){
          case 'top':
              return {
                  x: moveWhere(can_w),
                  y: -R,
                  v_x: rollRandomSpeed('top')[0],
                  v_y: rollRandomSpeed('top')[1],
                  r: R,
                  opac: 1,
                  phase: randomNumFrom(0, 10)
              }
              break;
          case 'right':
              return {
                  x: can_w + R,
                  y: moveWhere(can_h),
                  v_x: rollRandomSpeed('right')[0],
                  v_y: rollRandomSpeed('right')[1],
                  r: R,
                  opac: 1,
                  phase: randomNumFrom(0, 10)
              }
              break;
          case 'bottom':
              return {
                  x: moveWhere(can_w),
                  y: can_h + R,
                  v_x: rollRandomSpeed('bottom')[0],
                  v_y: rollRandomSpeed('bottom')[1],
                  r: R,
                  opac: 1,
                  phase: randomNumFrom(0, 10)
              }
              break;
          case 'left':
              return {
                  x: -R,
                  y: moveWhere(can_h),
                  v_x: rollRandomSpeed('left')[0],
                  v_y: rollRandomSpeed('left')[1],
                  r: R,
                  opac: 1,
                  phase: randomNumFrom(0, 10)
              }
              break;
      }
  }

  // Random speed: randomize to get a value for speed given a direction
  // Operating on cartesian coordinates:
  // If direction is top, x speed can be both and y speed is positive
  // If direction is right, x speed is negative and y speed can be both
  // If direction is bottom, x speed can be both and y speed is negative
  // If direction is left, x speed is positive and y speed can be both
  function rollRandomSpeed(pos){
      var  min = -1,
         max = 1;
      switch(pos){
          case 'top':
              return [randomNumFrom(min, max), randomNumFrom(0.1, max)];
              break;
          case 'right':
              return [randomNumFrom(min, -0.1), randomNumFrom(min, max)];
              break;
          case 'bottom':
              return [randomNumFrom(min, max), randomNumFrom(min, -0.1)];
              break;
          case 'left':
              return [randomNumFrom(0.1, max), randomNumFrom(min, max)];
              break;
          default:
              return;
              break;
      }
  }

  function moveWhere(length){
      return Math.ceil(Math.random() * length);
  }

  // Support functions: generate dots
  // Initiate dots
  function newDots(){
      Array.prototype.forEach.call(dots, function(b){
         if(!b.hasOwnProperty('type')){
             ctx.fillStyle = 'rgba('+dot_color.r+','+dot_color.g+','+dot_color.b+','+b.opac+')';
             ctx.beginPath();
             ctx.arc(b.x, b.y, R, 0, Math.PI*2, true);
             ctx.closePath();
             ctx.fill();
         }
      });
  }

  // Add dots if there a little dots
  // Initiate a new dot on a position in the limits of the canvas
  // (The dots appear on the outside and enter the inside of the canvas)
  function addDot(){
      if(dots.length < 100){
          dots.push(getRandomdot());
      }
  }

  // Support functions: Update dots
  // Get all dots and update x velocity, y velocity and opacity
  // Check how many dots are on canvas, and create more dots if value is less than minimum
  function updateDots(){
      var new_dots = [];
      Array.prototype.forEach.call(dots, function(d){
          d.x += d.v_x;
          d.y += d.v_y;

          if(d.x > -(50) && d.x < (can_w+50) && d.y > -(50) && d.y < (can_h+50)){
             new_dots.push(d);
          }

          // opac change
          d.phase += opac_f;
          d.opac = Math.abs(Math.cos(d.phase));
      });

      dots = new_dots.slice(0);
  }

  // Draw lines
  // Get pairs of dots and calculate the distance between them
  // When distance falls below a threshold, connect the dots with a line
  // The line gets stronger as the dots gets closer, this means when the ratio
  // of (distance/dist_limit) approaches 0
  function newLines(){
      var fraction, opac;
      for (var i = 0; i < dots.length; i++) {
          for (var j = i + 1; j < dots.length; j++) {

             fraction = getDisOf(dots[i], dots[j]) / dist_limit;

             if(fraction < 1){
                 opac = (1 - fraction).toString();

                 ctx.strokeStyle = 'rgba(150,150,150,'+opac+')';
                 ctx.lineWidth = line_wid;

                 ctx.beginPath();
                 ctx.moveTo(dots[i].x, dots[i].y);
                 ctx.lineTo(dots[j].x, dots[j].y);
                 ctx.stroke();
                 ctx.closePath();
             }
          }
      }
  }

  // Render the canvas
  function render(){
      ctx.clearRect(0, 0, can_w, can_h);

      newDots();

      newLines();

      updateDots();

      addDot();

      window.requestAnimationFrame(render);
  }

  // Initiate the first dots
  // input num: integer with how many dots to fill the canvas at start
  // Initiate its positions (x,y) and speeds (v_x,v_y) and opacity (random)
  // Initiate dot size (fixed)
  function initDots(num){
      for(var i = 1; i <= num; i++){
          dots.push({
              x: moveWhere(can_w),
              y: moveWhere(can_h),
              v_x: rollRandomSpeed('top')[0],
              v_y: rollRandomSpeed('top')[1],
              r: R,
              opac: 1,
              phase: randomNumFrom(0, 10)
          });
      }
  }
  // Init Canvas
  function initCanvas(){
      canvas.setAttribute('width', window.innerWidth);
      canvas.setAttribute('height', window.innerHeight);

      can_w = parseInt(canvas.getAttribute('width'));
      can_h = parseInt(canvas.getAttribute('height'));
  }
  window.addEventListener('resize', function(e){
      console.log('Window Resize...');
      initCanvas();
  });

  // Start the animation
  function goAnimation(){
      initCanvas();
      initDots(50);
      window.requestAnimationFrame(render);
  }
  goAnimation();

  // Mouse effect
  // The mouse can interact with the canvas
  // When the mouse enters the canvas, it acts as a new dot
  // Other dots can be connected to the mouse with the same line linking logic between dots
  canvas.addEventListener('mouseenter', function(){
      mouse_in = true;
      dots.push(mouse_dot);
  });
  canvas.addEventListener('mouseleave', function(){
      mouse_in = false;
      var new_dots = [];
      Array.prototype.forEach.call(dots, function(b){
          if(!b.hasOwnProperty('type')){
              new_dots.push(b);
          }
      });
      dots = new_dots.slice(0);
  });
  canvas.addEventListener('mousemove', function(e){
      var e = e || window.event;
      mouse_dot.x = e.pageX;
      mouse_dot.y = e.pageY;
  });

</script>


